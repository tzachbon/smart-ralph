# Progress: improve-task-generation

## Original Goal
I want to really improve how we generate tasks, like make sure it makes ALOT of tasks, as small / tiny as it can I really want it that they would be super clear and structured, and we even should encourage the implement to add more tasks or change existing ones if it deems necessary

## Interview Format
- Version: 1.0

## Intent Classification
- Type: REFACTOR
- Confidence: medium (1 keyword matched)
- Min questions: 3
- Max questions: 5
- Keywords matched: improve

## Interview Responses

### Goal Interview (from start.md)
- Problem: All of the above — tasks are too large/coarse-grained, not enough tasks generated, and tasks lack clarity and structure
- Constraints: Both task-planner and executor can modify tasks, with guardrails — executor can suggest changes but must follow a protocol (e.g., update tasks.md, log reasoning)
- Success criteria: Small atomic tasks with clear acceptance criteria per task, executor rarely needs to improvise, plus dynamic adaptation — executor can adapt the plan when needed
- Additional context: User referenced GSD (get-shit-done) framework as inspiration for task structure

## Research Phase
- Parallel team research completed
- Topics researched: 5 (atomic task decomposition, dynamic task modification, task-planner analysis, spec-executor analysis, existing tasks.md quality)
- Teammate count: 5 (2 research-analyst, 3 Explore)
- Additional direct research: GSD framework (planner, executor, plan-phase)
- Key finding: Current tasks average 22.4 per spec; target should be 40-60+ with atomic granularity
- Key finding: GSD uses max 2-3 tasks per plan with strict specificity requirements
- Key finding: Dynamic task modification needs structured executor→coordinator communication protocol

### Requirements Interview (from requirements.md)
- Primary users: AI agents (executor/planner) — the spec-executor and task-planner agents are the primary consumers of the improved task format
- Priority tradeoffs: Balanced approach — equal weight on both better initial generation AND dynamic modification capabilities
- Success criteria: Both + measurable quality improvement — more tasks, dynamic adaptation, AND fewer executor failures/improvisations

## Learnings
- Task-planner.md is ~485 lines; adding sizing rules + examples must stay concise to avoid prompt bloat (target < 8000 tokens total)
- implement.md coordinator already has fix task generation (section 6c) — modification request handling should follow same insertion pattern (Edit tool after task block)
- templates/tasks.md still has "Manual test of core flow" in POC Checkpoint Verify field (line 70) — contradicts no-manual-tasks rule, must fix
- spec-executor has no output channel to coordinator besides TASK_COMPLETE/failure — new TASK_MODIFICATION_REQUEST signal is a net-new protocol addition
- fixTaskMap in state already tracks per-task attempts — modification tracking can follow same pattern (modificationMap)
- Related spec parallel-task-execution uses [P] markers; task modifications must not insert tasks mid-parallel-batch to avoid breaking batch boundaries
- 15% of existing tasks use vague verification — template examples are the highest-leverage fix for this
- Design: Sizing rules section adds ~300 tokens to task-planner.md (well under 8000 budget). Quality checklist expansion adds ~100 tokens. Total planner ~4900 tokens.
- Design: TASK_MODIFICATION_REQUEST uses JSON payload with embedded markdown task blocks — JSON for coordinator parsing, markdown for tasks.md consistency
- Design: SPLIT_TASK sends both TASK_MODIFICATION_REQUEST + TASK_COMPLETE (executor done with its part). ADD_PREREQUISITE sends only TASK_MODIFICATION_REQUEST (task blocked).
- Design: modificationMap is separate from fixTaskMap — different semantics (proactive adaptation vs reactive recovery). Both can exist for same task independently.
- Design: Parallel batch interaction — modification request breaks parallel batch, remaining tasks re-evaluated as sequential. Prevents mid-batch insertion corruption.
- Design: 7 files modified total. Largest change is implement.md (~80 lines for Section 6e). All other files < 50 lines added.
- Design: Backwards compatibility ensured via jq `//=` defaults for new state fields (modificationMap, maxModificationsPerTask, maxModificationDepth)

### Design Interview (from design.md)
- Architecture style: Extend existing architecture — modify task-planner.md, spec-executor.md, implement.md, and templates in-place
- Technology constraints: No constraints — stick with markdown prompts and existing tooling
- Integration approach: Use existing APIs and interfaces — extend TASK_COMPLETE protocol with new signals, use existing state management patterns

### Tasks Interview (from tasks.md)
- Testing depth: Standard - unit + integration — unit tests and integration tests where applicable, balanced for a markdown-prompt plugin
- Deployment approach: Standard CI/CD pipeline — push changes, let existing CI checks validate
- Execution priority: Balanced - reasonable quality with speed — decent quality throughout without over-engineering

### Design Update: Karpathy Coding Principles Integration
- Karpathy principles (think-first, simplicity, surgical, goal-driven) distributed across components at point-of-use rather than centralized
- Planner gets simplicity + surgical principles in Task Sizing Rules — prevents over-engineered task descriptions
- Executor gets think-first principle in Task Modification Requests — surfaces uncertainties via TASK_MODIFICATION_REQUEST instead of silently improvising
- Template gets all 4 principles as "Task Writing Principles" subsection — serves as quick reference for task authors
- Goal-driven principle is highest-impact change: shifts emphasis from Do steps (imperative) to Done when/Verify (declarative success criteria)
- Multi-step verify pattern `1. [Step] -> verify: [check]` from Karpathy aligns naturally with existing task Verify field convention
- 4th bad/good example pair added to template demonstrating imperative-to-goal-driven transformation
- Quality checklist expanded with 4 new principle-based checks (meaningful Done when, no speculative features, no unrelated files, explicit assumptions)
- Token impact modest: ~100 extra tokens in planner, ~150 extra in template. Still well under 8000 budget

## Completed Tasks
- [x] 1.1 Add Task Writing Guide header and principles to templates/tasks.md
- [x] 1.2 Add Bad vs Good Example 1 (File Creation) to templates/tasks.md
- [x] 1.3 Add Bad vs Good Example 2 (Integration) to templates/tasks.md
- [x] 1.4 [VERIFY] Quality checkpoint: grep validation of template structure
- [x] 1.5 Add Bad vs Good Example 3 (Refactoring) to templates/tasks.md
- [x] 1.6 Add Bad vs Good Example 4 (Goal-Driven) to templates/tasks.md
- [x] 1.7 Fix POC Checkpoint manual verification in templates/tasks.md
- [x] 1.8 [VERIFY] Quality checkpoint: full template validation
- [x] 1.9 Add Task Sizing Rules section to task-planner.md
- [x] 1.10 Add target task count and principles to Task Sizing Rules
- [x] 1.11 [VERIFY] Quality checkpoint: task-planner sizing rules complete
- [x] 1.12 Replace Quality Checklist in task-planner.md with expanded version
- [x] 1.13 [VERIFY] Quality checkpoint: task-planner.md fully updated
- [x] 1.14 Add Task Modification Requests header and when-to-request rules to spec-executor.md
- [x] 1.15 Add TASK_MODIFICATION_REQUEST signal format to spec-executor.md
- [x] 1.16 [VERIFY] Quality checkpoint: spec-executor signal format
- [x] 1.17 Add modification types table and rules to spec-executor.md
- [x] 1.18 Add ADD_PREREQUISITE example and closing tags to spec-executor.md
- [x] 1.19 [VERIFY] Quality checkpoint: spec-executor.md modification protocol complete
- [x] 1.20 Add modificationMap to spec.schema.json
- [x] 1.21 Add maxModificationsPerTask and maxModificationDepth to spec.schema.json
- [x] 1.23 Add modificationMap fields to implement.md state initialization
- [x] 1.24 Add Section 6e header and detection logic to implement.md
- [x] 1.25 Add Parse and Validate subsections to Section 6e
- [x] 1.27 Add SPLIT_TASK handler to Section 6e
- [x] 1.28 Add ADD_PREREQUISITE handler to Section 6e
- [x] 1.29 Add ADD_FOLLOWUP handler to Section 6e

## Current Task
Awaiting next task

## Next
Task 1.30: [VERIFY] Quality checkpoint: all 3 modification handlers

### Task Planning
- 48 total tasks across 5 phases: Phase 1 (38 tasks, 79%), Phase 2 (6 tasks, 13%), Phase 3 (10 tasks, 21%), Phase 4 (3 tasks, 6%), Phase 5 (3 tasks, 6%) -- note: percentages reflect checkpoint overlap
- Phase 1 is largest because each file modification is broken into atomic tasks (1 section insertion per task) with quality checkpoints every 2-3 tasks
- Key dependency: schema tasks (1.20-1.22) should complete before implement.md state init (1.23) since the schema defines the structure that init creates
- Line numbers in design doc are pre-insertion; executor must use content-based matching (Edit tool old_string/new_string) not line numbers since earlier insertions shift lines
- All 7 files are markdown/JSON prompt files with no build step -- verification is purely grep/jq based
- No existing test framework (no package.json, no pnpm) -- CI uses bats-tests.yml, plugin-version-check.yml, spec-file-check.yml
- Version bump from 3.4.1 to 3.5.0 (minor: new feature) in both plugin.json and marketplace.json
- templates/tasks.md "Manual test" at line 70 is the only manual verification pattern found in templates; will be fixed in task 1.7

### Verification: 1.4 [VERIFY] Quality checkpoint: grep validation of template structure
- Status: PASS
- Check 1: `grep -c "### Bad vs. Good Examples"` = 1 (expected 1) -- PASS
- Check 2: `grep -c "Example 1:"` = 1 (expected 1) -- PASS
- Check 3: `grep -c "Example 2:"` = 1 (expected 1) -- PASS
- Structural order verified: Task Writing Guide (L29) > Principles (L33) > Bad vs Good Examples (L40) > Example 1 (L42) > Example 2 (L60) > Phase 1 (L78)
- No fixes needed, no commit required

### Verification: 1.8 [VERIFY] Quality checkpoint: full template validation
- Status: PASS
- Check 1: `grep -c "Example [1-4]:"` = 4 (expected 4) -- PASS
- Check 2: `grep -qi "manual test"` = not found (expected absent) -- PASS
- Check 3: `grep -q "Task Writing Principles"` = found (expected present) -- PASS
- Structural order verified: Task Writing Principles (L33) > Bad vs Good Examples (L40) > Example 1 (L42) > Example 2 (L60) > Example 3 (L78) > Example 4 (L95) > Phase 1 (L114)
- All 4 examples present, no manual test references, principles section exists
- No fixes needed, no commit required

### Verification: 1.11 [VERIFY] Quality checkpoint: task-planner sizing rules complete
- Status: PASS
- Check 1: `grep -q "Max 4 numbered steps"` = found (L289) -- PASS
- Check 2: `grep -q "Max 3 files"` = found (L290) -- PASS
- Check 3: `grep -q "Simplicity principle"` = found (L309) -- PASS
- Check 4: `grep -q "Surgical principle"` = found (L311) -- PASS
- Additional components verified: Split if (L293), Combine if (L300), Target task count (L305), Clarity test (L313)
- Task Sizing Rules section spans lines 283-314, well-structured within `<mandatory>` block
- No fixes needed, no commit required

### Verification: 1.13 [VERIFY] Quality checkpoint: task-planner.md fully updated
- Status: PASS
- Check 1: `grep -q "## Task Sizing Rules"` = found (L283) -- PASS
- Check 2: `grep -q "Total task count is 40+"` = found (L562) -- PASS
- Check 3: `grep -q "50-60%"` = found (L307) -- PASS
- Check 4: `grep -q "## Quality Checklist"` = found (L550) -- PASS
- Check 5: `grep -q "meaningful.*Done when"` = found (L563) -- PASS
- Check 6: `grep -q "speculative features"` = found (L564) -- PASS
- Check 7: `grep -q "unrelated to its stated goal"` = found (L565) -- PASS
- Check 8: `grep -q "assumptions explicitly"` = found (L566) -- PASS
- Both sections present: Task Sizing Rules (L283-314) and expanded Quality Checklist (L550-567)
- Quality Checklist has 14 items total: 10 original + 4 new Karpathy-based checks
- No fixes needed, no commit required

### Verification: 1.16 [VERIFY] Quality checkpoint: spec-executor signal format
- Status: PASS
- Check 1: `grep -q "## Task Modification Requests"` = found (L361) -- PASS
- Check 2: `grep -q "SPLIT_TASK"` = found (L381) -- PASS
- Check 3: `grep -q "ADD_PREREQUISITE"` = found (L381) -- PASS
- Check 4: `grep -q "ADD_FOLLOWUP"` = found (L381) -- PASS
- Check 5: `grep -q "TASK_MODIFICATION_REQUEST"` = found (L378) -- PASS
- Check 6: `grep -q "When to request modification"` = found (L368) -- PASS
- Check 7: `grep -q "Think before acting"` = found (L364) -- PASS
- All 3 modification types present on L381 (union type in signal format JSON)
- Note: task verify command uses `grep -c` (line count) which returns 1 since all 3 types are on one line. The "Done when" criteria (all 3 types referenced at least once) IS satisfied -- `grep -o | sort -u | wc -l` confirms 3 unique types.
- Section spans lines 361-389, complete per tasks 1.14 + 1.15 scope
- No fixes needed, no commit required

### Verification: 1.19 [VERIFY] Quality checkpoint: spec-executor.md modification protocol complete
- Status: PASS
- Check 1: `grep -q "## Task Modification Requests"` = found (L361) -- PASS
- Check 2: `grep -q "TASK_MODIFICATION_REQUEST"` = found (L378) -- PASS
- Check 3: `grep -q "Max 3 modification"` = found (L400) -- PASS
- Check 4: `grep -q "Example: ADD_PREREQUISITE"` = found (L406) -- PASS
- Full protocol section spans lines 361-425 within `<mandatory>` block
- All components present: think-first principle, when-to-request triggers, signal format (JSON), modification types table, rules with limits, ADD_PREREQUISITE example
- Section properly closed with `</mandatory>` tag at L425
- No fixes needed, no commit required

### Verification: 1.22 [VERIFY] Quality checkpoint: schema validation
- Status: PASS
- Check 1: `jq empty spec.schema.json` = valid JSON -- PASS
- Check 2: `jq '.definitions.state.properties | keys[]' | grep modificationMap` = found -- PASS
- Check 3: All 3 new fields present: modificationMap, maxModificationsPerTask, maxModificationDepth -- PASS
- Check 4: modificationMap inner structure has `count` and `modifications` properties -- PASS
- Check 5: maxModificationsPerTask default = 3, maxModificationDepth default = 2 -- PASS
- Check 6: Modification type enum contains all 3 types: SPLIT_TASK, ADD_PREREQUISITE, ADD_FOLLOWUP -- PASS
- Schema is valid JSON with all new fields properly defined
- No fixes needed, no commit required

### Verification: 1.26 [VERIFY] Quality checkpoint: Section 6e header and validation
- Status: PASS
- Check 1: `grep -q "### 6e"` = found (L1015) -- PASS
- Check 2: `grep -q "Validate Request"` = found (L1035) -- PASS
- Check 3: `grep -q "depth"` = found (L1040) -- PASS
- All 3 subsections present: Detection (L1019), Parse Modification Request (L1023), Validate Request (L1035)
- Section 6e spans lines 1015-1041 with complete modification request handling logic
- No fixes needed, no commit required

### Verification: 1.30 [VERIFY] Quality checkpoint: all 3 modification handlers
- Status: PASS
- Check 1: `grep -q "SPLIT_TASK" implement.md` = found (L1028, L1045) -- PASS
- Check 2: `grep -q "ADD_PREREQUISITE" implement.md` = found (L1028, L1053) -- PASS
- Check 3: `grep -q "ADD_FOLLOWUP" implement.md` = found (L1028, L1062) -- PASS
- All 3 handlers are dedicated subsections under "Process by Type" (L1043) with numbered step lists
- SPLIT_TASK (L1045-1051): 6 steps — mark complete, insert sub-tasks, update state, modificationMap, set taskIndex, log
- ADD_PREREQUISITE (L1053-1060): 7 steps — no mark, insert before, update state, modificationMap, delegate prereq, retry original, log
- ADD_FOLLOWUP (L1062-1068): 6 steps — already complete, insert after, update state, modificationMap, normal advance, log
- Section 6e spans lines 1015-1068, complete with detection, parsing, validation, and all 3 type handlers
- No fixes needed, no commit required
