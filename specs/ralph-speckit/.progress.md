# Progress: ralph-speckit

## Original Goal

Create a new Claude Code plugin called `ralph-speckit` that follows the patterns of `ralph-specum` but uses GitHub's [spec-kit](https://github.com/github/spec-kit) methodology as its foundation.

The plugin will implement:
- Constitution-first approach (project-level governing principles)
- Specify phase (WHAT + WHY, not HOW)
- Plan phase (technical implementation with research)
- Tasks phase (actionable breakdown organized by user story)
- Implement phase (task-by-task execution with stop-handler)

Key differentiators from ralph-specum:
- Constitution as project-level persistent memory
- Feature IDs with numeric prefix (001-feature-name)
- Optional clarify/analyze phases
- .speckit/ directory structure

## Reference Document

See `RALPH-SPECKIT-PLAN.md` in repository root for comprehensive implementation plan.

## Phase: Tasks (Complete)

Tasks phase completed. See `tasks.md` for 45 implementation tasks across 4 phases.

## Completed Tasks

- [x] Research phase - analyzed GitHub spec-kit methodology and ralph-specum codebase
- [x] Requirements phase - defined 9 user stories with 40 acceptance criteria, 14 functional requirements, 7 NFRs
- [x] Design phase - created architecture, components, state machine, data flow, templates
- [x] Tasks phase - generated 45 tasks organized by user story (POC-first workflow)
- [x] 1.1 Install and verify spec-kit CLI - already installed
- [x] 1.2 Run `specify init` to bootstrap plugin
- [x] 1.3 Document spec-kit generated structure
- [x] 1.4 [VERIFY] Quality checkpoint: spec-kit bootstrap complete
- [x] 2.1 Create hooks directory and configuration - hooks.json created with Stop hook
- [x] 2.2 Create stop-watcher.sh adapted for .specify paths - adapted paths and made executable
- [x] 2.4 Create state schema for .speckit-state.json - JSON schema with all state fields
- [x] 2.5 Create spec-executor agent - adapted from ralph-specum with .specify paths
- [x] 2.6 Create qa-engineer agent - adapted with .specify paths, VERIFICATION_PASS/FAIL signals
- [x] 3.1 Create implement command - task loop entry point with Ralph Wiggum integration
- [x] 3.2 Create start command - smart entry point with feature ID auto-increment
- [x] 3.3 Create status command - displays feature, phase, progress, blockers

## Current Task

Awaiting next task

## Next

Task 3.4: Create switch command

## Learnings

- Spec-kit introduces "constitution" as project-level persistent memory - this is fundamentally different from ralph-specum's per-spec approach
- Spec-kit inverts the "code is king" paradigm - specifications become the source of truth that generates implementation
- Six core principles from spec-kit: Specifications as Lingua Franca, Executable Specifications, Continuous Refinement, Research-Driven Context, Bidirectional Feedback, Branching for Exploration
- Stop-handler.sh is the core of the task loop - needs path adaptation from `./specs/` to `.speckit/specs/`
- Feature IDs with numeric prefixes (001, 002) require auto-increment logic in start.md
- The delegation principle is critical: commands coordinate, agents implement - this must be preserved
- All agents follow consistent pattern: frontmatter, system prompt, "When Invoked" workflow, "Append Learnings", "Final Step: Set Awaiting Approval"
- No build step required - plugin changes take effect on Claude Code restart
- spec-kit embeds research in the plan phase rather than having a dedicated research phase
- Optional phases (clarify, analyze, checklist) add flexibility without breaking the core workflow
- Requirements phase insight: User stories naturally map to spec-kit's "organize tasks by user story" pattern, enabling end-to-end traceability
- The 9 user stories cover: governance (US-1), specify (US-2), plan (US-3), tasks (US-4), implement (US-5), workflow (US-6), progress (US-7), clarify (US-8), analyze (US-9)
- Traceability annotations (_Spec: FR-X, AC-X.X_ and _Plan: Component_) are critical for maintaining connection between intent and implementation
- NFRs focus on reliability metrics (0% corruption, 100% schema compliance) since the plugin must work reliably in autonomous mode
- Risk of "spec creep" into implementation details requires explicit template validation and agent prompt guidance
- Open questions from research were resolved: constitution uses guidance (not enforcement), simple numeric IDs, no quick mode initially
- Design insight: Stop-watcher.sh acts as watcher only - Ralph Wiggum handles loop continuation via exit code 2
- Plugin requires 8 agents, 12 commands, 6 templates, 1 schema - approximately 30 files total
- State file schema adds featureId field and changes phases to: specify, plan, tasks, execution
- Tasks must be organized by user story (US-1, US-2) rather than by POC phase like ralph-specum
- Traceability matrix links all 14 functional requirements to specific components and commands
- Constitution lives at .speckit/memory/constitution.md - separate from feature specs
- Feature ID auto-increment requires scanning existing .speckit/specs/ directories for highest ID
- Task planning insight: 45 tasks organized across 4 phases (POC: 35, Refactoring: 6, Testing: 4, Quality: 6)
- Task dependency: US-6 (Start) must be implemented first as foundation for all other workflows
- Parallel tasks marked with [P] can be executed concurrently (e.g., templates alongside commands)
- Quality checkpoints inserted every 2-3 tasks to catch issues early
- Stop-watcher.sh adapted from stop-handler.sh with path changes only - core logic preserved
- File count: 30 files total (1 manifest, 12 commands, 8 agents, 6 templates, 2 hooks, 1 schema)
- POC shortcuts: No automated tests since plugin is markdown-based. Manual testing via --plugin-dir flag.
- Critical path: manifest > hooks > start > constitution > specify > plan > tasks > implement
- Spec-kit v0.0.90 generates different structure than expected: `.specify/` has memory/, scripts/, templates/ (no commands/ or specs/). Commands go in `.claude/commands/` as slash command .md files. specs/ directory created on-demand per feature.

## Spec-kit Generated Structure

**Directory**: `plugins/ralph-speckit/.specify/`

### Directory Layout
```
.specify/
├── memory/
│   └── constitution.md      # Project governance principles template
├── templates/
│   ├── checklist-template.md   # Checklist generation template
│   ├── spec-template.md        # Feature specification template (user stories, requirements, ACs)
│   ├── plan-template.md        # Implementation plan template (technical context, structure)
│   ├── agent-file-template.md  # AI agent context file template (CLAUDE.md, etc.)
│   └── tasks-template.md       # Task list template (organized by user story)
└── scripts/bash/
    ├── common.sh               # Shared functions (get_repo_root, get_current_branch, get_feature_paths)
    ├── create-new-feature.sh   # Creates feature branch and spec directory (###-feature-name format)
    ├── setup-plan.sh           # Copies plan template to feature directory
    ├── check-prerequisites.sh  # Validates branch, plan.md, optional docs presence
    └── update-agent-context.sh # Updates AI agent files (CLAUDE.md, GEMINI.md, etc.) from plan.md
```

### Key Observations

**No commands/ directory**: spec-kit v0.0.90 does NOT generate commands in .specify/. Commands are expected in `.claude/commands/` as slash command .md files.

**No specs/ directory**: Feature specs created on-demand at `specs/###-feature-name/` by create-new-feature.sh

**Templates**:
- `spec-template.md`: User stories with priorities (P1, P2, P3), acceptance scenarios (Given/When/Then), functional requirements (FR-001), key entities, success criteria
- `plan-template.md`: Technical context (language, framework, storage, testing), constitution check, project structure (single/web/mobile options)
- `tasks-template.md`: Organized by user story, phases (Setup, Foundational, User Stories, Polish), parallel markers [P], MVP-first approach
- `checklist-template.md`: Category-based CHK001 items with checkboxes
- `agent-file-template.md`: Auto-generated dev guidelines for AI agents

**Scripts**:
- `common.sh`: Foundation for all scripts. Handles git/non-git repos, feature branch validation (###-format), path resolution
- `create-new-feature.sh`: Auto-increments feature number by scanning specs/ and git branches. Creates branch + copies spec-template.md
- `check-prerequisites.sh`: Validates plan.md exists, optionally requires tasks.md. JSON output mode available
- `update-agent-context.sh`: Parses plan.md, updates AI agent files with tech stack, commands, project structure. Supports 15+ AI agents (Claude, Gemini, Copilot, Cursor, etc.)

**constitution.md**: Template with placeholders for principles. Not populated. Expects user to fill [PRINCIPLE_N_NAME] and [PRINCIPLE_N_DESCRIPTION].

**Feature ID format**: `###-feature-name` (e.g., 001-user-auth). Scripts enforce 3-digit zero-padded prefix.

**Integration implications for ralph-speckit**:
1. Commands must be created separately (not generated by spec-kit)
2. State management (.speckit-state.json) is ralph-speckit addition, not spec-kit
3. Execution loop (spec-executor, qa-engineer, stop-watcher) entirely ralph-speckit
4. Feature directory is `specs/###-name/` not `.specify/specs/###-name/`
5. Scripts use `specs/` path, ralph-speckit should use same convention

## Blockers

(none)

## Next Steps

1. ~~Complete research phase~~ DONE
2. ~~Generate requirements~~ DONE
3. ~~Create technical design~~ DONE
4. ~~Generate tasks~~ DONE (regenerated with wrapper approach)
5. Execute implementation

## Learnings (Task Planning - Wrapper Approach)

- **Key approach change**: Instead of creating 30+ files from scratch, use spec-kit CLI (`specify init`) to bootstrap base structure
- spec-kit CLI generates: commands (constitution, specify, plan, tasks, implement, clarify, analyze, checklist), templates, .specify/ directory structure
- ralph-speckit becomes a thin wrapper adding only: stop-handler hook, spec-executor/qa-engineer agents, session commands (start/status/switch/cancel), state management
- **File count reduced**: 11 unique ralph-speckit files vs 30+ in original approach
- Wrapper benefits: reuse tested spec-kit code, stay aligned with spec-kit updates, smaller maintenance surface
- **Risk identified**: spec-kit CLI may generate different structure than expected. Task 1.3 documents actual output to inform integration.
- Stop-watcher.sh remains watcher-only (exit 0). Ralph Wiggum handles loop continuation via exit code 2.
- State file path changes: `.specify/specs/$FEATURE/.speckit-state.json` instead of `./specs/$SPEC/.ralph-state.json`
- Feature pointer at `.specify/.current-feature` instead of `specs/.current-spec`
- 25 tasks across 6 phases (Foundation: 4, Integration: 7, Session Commands: 6, Templates: 3, Testing: 3, Quality Gates: 4)

### Verification: 1.4 [VERIFY] Quality checkpoint: spec-kit bootstrap complete
- Status: PASS (after fix)
- Issue found: plugin.json was missing from .claude/ directory
- Fix applied: Created plugin.json with correct structure
- Verified components:
  - plugin.json: PASS (created)
  - .claude/commands/: PASS (9 commands)
  - .specify/templates/: PASS (5 templates)
  - .specify/memory/: PASS (constitution.md)
  - .specify/scripts/bash/: PASS (5 scripts)

### Verification: 2.3 [VERIFY] Quality checkpoint: hook syntax valid
- Status: PASS
- Commands: jq . hooks.json (0), bash -n stop-watcher.sh (0)
- Files verified:
  - plugins/ralph-speckit/hooks/hooks.json: Valid JSON
  - plugins/ralph-speckit/hooks/scripts/stop-watcher.sh: Valid bash syntax

### Verification: 2.7 [VERIFY] Quality checkpoint: agents valid
- Status: PASS
- Commands: head -10 spec-executor.md (0), head -10 qa-engineer.md (0)
- Verified components:
  - spec-executor.md frontmatter: PASS (name, description, model fields present)
  - qa-engineer.md frontmatter: PASS (name, description, model fields present)
  - Path references: PASS (both use .specify/specs/<feature>/ pattern)
  - File permissions: PASS (readable, 644)
  - plugin.json: PASS (located at .claude/plugin.json)
